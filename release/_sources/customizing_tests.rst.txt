.. _customizing_tests:

Customizing Patcher and TestCase
--------------------------------

Both ``fake_filesystem_unittest.Patcher`` and ``fake_filesystem_unittest.TestCase``
provide a few arguments to handle cases where patching does not work out of
the box.
In case of ``fake_filesystem_unittest.TestCase``, these arguments can either
be set in the TestCase instance initialization, or passed to ``setUpPyfakefs()``.

.. note:: If you need these arguments in ``PyTest``, you must
  use ``Patcher`` directly instead of the ``fs`` fixture. Alternatively,
  you can add your own fixture with the needed parameters.

  An example for both approaches can be found in
  `pytest_fixture_test.py <https://github.com/jmcgeheeiv/pyfakefs/blob/master/pyfakefs/tests/pytest/pytest_fixture_test.py>`__
  with the example fixture in `conftest.py <https://github.com/jmcgeheeiv/pyfakefs/blob/master/pyfakefs/tests/pytest/conftest.py>`__.
  We advice to use this example fixture code as a template for your customized
  pytest plugins.

modules_to_reload
~~~~~~~~~~~~~~~~~
Pyfakefs patches modules that are imported before starting the test by
finding and replacing file system modules in all loaded modules at test
initialization time.
This allows to automatically patch file system related modules that are:

- imported directly, for example:

.. code:: python

  import os
  import pathlib.Path

- imported as another name:

.. code:: python

  import os as my_os

- imported using one of these two specially handled statements:

.. code:: python

  from os import path
  from pathlib import Path

Additionally, functions from file system related modules are patched
automatically if imported like:

.. code:: python

  from os.path import exists
  from os import stat

This also works if importing the functions as another name:

.. code:: python

  from os.path import exists as my_exists
  from io import open as io_open
  from builtins import open as bltn_open

There are a few cases where automatic patching does not work. We know of two
specific cases where this is the case:

- initializing global variables:

.. code:: python

  from pathlib import Path

  path = Path("/example_home")

In this case, ``path`` will hold the real file system path inside the test.

- initializing a default argument:

.. code:: python

  import os

  def check_if_exists(filepath, file_exists=os.path.exists):
      return file_exists(filepath)

Here, ``file_exists`` will not be patched in the test.

To get these cases to work as expected under test, the respective modules
containing the code shall be added to the ``modules_to_reload`` argument (a
module list).
The passed modules will be reloaded, thus allowing pyfakefs to patch them
dynamically. All modules loaded after the initial patching described above
will be patched using this second mechanism.

Given tat the example code shown above is located in the file ``example/sut.py``,
the following code will work:

.. code:: python

  # example using unittest
  class ReloadModuleTest(fake_filesystem_unittest.TestCase):
      def setUp(self):
          self.setUpPyfakefs(modules_to_reload=[example.sut])

      def test_path_exists(self):
          file_path = '/foo/bar'
          self.fs.create_dir(file_path)
          self.assertTrue(example.sut.check_if_exists(file_path))

  # example using Patcher
  def test_path_exists():
      with Patcher() as patcher:
        file_path = '/foo/bar'
        patcher.fs.create_dir(file_path)
        assert example.sut.check_if_exists(file_path)

Example using pytest:

.. code:: python

  # conftest.py
  ...
  from example import sut

  @pytest.fixture
  def fs_reload_sut():
      patcher = Patcher(modules_to_reload=[sut])
      patcher.setUp()
      linecache.open = patcher.original_open
      tokenize._builtin_open = patcher.original_open
      yield patcher.fs
      patcher.tearDown()

  # test_code.py
  ...
  def test_path_exists(fs_reload_sut):
      file_path = '/foo/bar'
      fs_reload_sut.create_dir(file_path)
      assert example.sut.check_if_exists(file_path)


modules_to_patch
~~~~~~~~~~~~~~~~
Sometimes there are file system modules in other packages that are not
patched in standard pyfakefs. To allow patching such modules,
``modules_to_patch`` can be used by adding a fake module implementation for
a module name. The argument is a dictionary of fake modules mapped to the
names to be faked.

This mechanism is used in pyfakefs itself to patch the external modules
`pathlib2` and `scandir` if present, and the following example shows how to
fake a module in Django that uses OS file system functions:

.. code:: python

  class FakeLocks(object):
  """django.core.files.locks uses low level OS functions, fake it."""
  _locks_module = django.core.files.locks

  def __init__(self, fs):
  """Each fake module expects the fake file system as an __init__ parameter."""
      # for a real example, fs can be saved here and used in the implementation
      pass

  @staticmethod
  def lock(f, flags):
      return True

  @staticmethod
  def unlock(f):
      return True

  def __getattr__(self, name):
      return getattr(self._locks_module, name)


  with Patcher(modules_to_patch={'django.core.files.locks': FakeLocks}):
      test_django_stuff()


additional_skip_names
~~~~~~~~~~~~~~~~~~~~~
This may be used to add modules that shall not be patched. This is mostly
used to avoid patching the Python file system modules themselves, but may be
helpful in some special situations. There is also the global
variable ``Patcher.SKIPNAMES`` that can be extended for that purpose, though
this seldom should be needed (except for own pytest plugins, as shown in
the example mentioned above)

use_dynamic_patch
~~~~~~~~~~~~~~~~~
If ``True`` (the default), dynamic patching after setup is used (for example
for modules loaded locally inside of functions).
Can be switched off if it causes unwanted side effects. This parameter will
probably removed in the future - it has been added while dynamic patching
was an experimental feature.
